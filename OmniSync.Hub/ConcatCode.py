import os

# Hardcoded text to be prepended to the output file
PREPENDED_TEXT = """/*
 * This is a concatenated file generated by a Python script.
 * It contains the contents of a wide variety of source code, configuration, and script files
 * found recursively from the current directory.
 */

"""

# The name of the output file
OUTPUT_FILENAME = "concatenated_files.txt"

# The extensions of the files to find
FILE_EXTENSIONS = (
    # Programming Languages
    ".py", ".cs", ".java", ".js", ".ts", ".go", ".rs", ".rb", ".php", ".swift", ".kt", ".c", ".cpp", ".h", ".m", ".f90",
    # Markup and Configuration
    ".xml", ".html", ".htm", ".css", ".scss", ".less", ".json", ".yaml", ".yml", ".ini", ".cfg", ".conf", ".env", ".md", ".txt",
    # Build and Project Files
    ".csproj", ".fsproj", ".vbproj", ".sln", ".gradle", ".pom", ".sh", ".ps1", ".bat", ".cmake", "Dockerfile", "Makefile",
    # Other Scripting/Data
    ".sql", ".lua", ".dart", ".r"
)

def find_and_concatenate_files():
    """
    Finds all files with specified extensions recursively from the current
    directory and concatenates them into a single text file.
    """
    file_paths = []
    # Recursively find all files with the specified extensions
    for root, _, files in os.walk("."):
        for file in files:
            if file.endswith(FILE_EXTENSIONS):
                # Use os.path.normpath to ensure consistent path separators (e.g., \ on Windows)
                file_paths.append(os.path.normpath(os.path.join(root, file)))

    # Sort the file paths for a consistent order
    file_paths.sort()

    # Open the output file in write mode
    try:
        with open(OUTPUT_FILENAME, "w", encoding="utf-8") as outfile:
            # Prepend the hardcoded text
            outfile.write(PREPENDED_TEXT)

            # Iterate through the found files and append their content
            for file_path in file_paths:
                try:
                    with open(file_path, "r", encoding="utf-8", errors="ignore") as infile:
                        # Indicate the filename using a more robust multi-line f-string
                        outfile.write(f"""
//==============================================================================
// File: {file_path}
//==============================================================================
""")
                        outfile.write("\n\n")
                        # Write the content of the file
                        outfile.write(infile.read())
                        outfile.write("\n\n")
                except Exception as e:
                    print(f"Error reading file {file_path}: {e}")
        print(f"Successfully concatenated {len(file_paths)} files into {OUTPUT_FILENAME}")
    except IOError as e:
        print(f"Error writing to output file {OUTPUT_FILENAME}: {e}")

if __name__ == "__main__":
    find_and_concatenate_files()